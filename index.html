<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>AlgorithmVisualizer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="css/styles.css" />
</head>
<body>
  <header class="header">
    AlgorithmVisualizer<br>
    <span class="subtitle">
      情報系のためのアルゴリズム可視化ツール
    </span>
  </header>

  <main class="container">
    <!-- 色の凡例 -->
    <section class="section legend">
      <h3 class="section-title">■ 色の凡例</h3>
      <div class="legend-items">
        <div class="legend-item">
          <div class="legend-color normal"></div>
          <span>通常セル</span>
        </div>
        <div class="legend-item">
          <div class="legend-color highlight"></div>
          <span>現在更新中セル</span>
        </div>
        <div class="legend-item">
          <div class="legend-color confirmed"></div>
          <span>最終確定セル／確定経路</span>
        </div>
      </div>
    </section>

    <!-- アルゴリズム選択 -->
    <section class="section controls">
      <label class="label" for="algoSelect">アルゴリズムを選択：</label>
      <select id="algoSelect" class="select">
        <option value="">-- 選択してください --</option>
        <option value="edit">Edit Distance (編集距離)</option>
        <option value="knapsack">0/1 Knapsack</option>
        <option value="sorting">Sorting</option>
        <option value="searching">Searching</option>
        <option value="forward">Forward アルゴリズム</option>
        <option value="viterbi">Viterbi アルゴリズム</option>
        <option value="lp">線形計画法（単純形法）</option>
        <option value="hash">ハッシュ法（オープンアドレス法）</option>
      </select>
    </section>

    <!-- ================================
         1) Edit Distance（編集距離）
         ================================ -->
    <section id="editControls" class="section algo-controls" style="display:none;">
      <h2 class="section-title">Edit Distance（編集距離）</h2>
      <div class="controls">
        <label class="label">文字列 1（s1）:
          <input type="text" id="edit_s1" class="input" placeholder="例: waseda" />
        </label>
        <label class="label">文字列 2（s2）:
          <input type="text" id="edit_s2" class="input" placeholder="例: university" />
        </label>
        <label class="label">遅延 (秒):
          <input type="number" step="0.01" id="edit_delay" class="input" value="0.1" style="width: 60px;" />
        </label>
        <button id="editInitBtn" class="btn">Initialize</button>
        <button id="editRandomBtn" class="btn">ランダム生成</button>
      </div>

      <div id="editTableWrapper" class="table-wrapper">
        <table id="editTable"></table>
      </div>

      <div class="controls">
        <label class="label">
          Auto Play 倍率：
          <select id="editSpeedSelect" class="select speed-select" style="max-width:120px; margin-left:4px;">
            <option value="0.5">0.5×</option>
            <option value="1.0" selected>1.0×</option>
            <option value="1.5">1.5×</option>
            <option value="2.0">2.0×</option>
            <option value="3.0">3.0×</option>
          </select>
        </label>
      </div>
      <div class="step-controls">
        <button id="editPrevBtn" class="btn" disabled>前へ</button>
        <button id="editNextBtn" class="btn" disabled>次へ</button>
        <button id="editAutoBtn" class="btn" disabled>Auto Play</button>
      </div>
      <div id="editProgress" class="progress">ステップ 0 / 0</div>
      <div id="editDesc" class="description">
        <strong>編集距離（Levenshtein Distance）とは：</strong><br>
        文字列 A を文字列 B に変換するために必要な挿入・削除・置換の最小回数を計算します。<br>
        DP (動的計画法) テーブルを使い、ステップごとにセルをどのように埋めるかを可視化します。<br>
        <strong>C 言語実装例：</strong>
        <pre><code>
// C 言語：Edit Distance（Levenshtein Distance）の例
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define MAXLEN 100

int min3(int a, int b, int c) {
    int m = a < b ? a : b;
    return m < c ? m : c;
}

int edit_distance(const char *s1, const char *s2) {
    int n = strlen(s1), m = strlen(s2);
    int dp[MAXLEN+1][MAXLEN+1];
    for (int i = 0; i <= n; i++) dp[i][0] = i;
    for (int j = 0; j <= m; j++) dp[0][j] = j;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            int cost = (s1[i-1] == s2[j-1]) ? 0 : 1;
            dp[i][j] = min3(dp[i-1][j] + 1,
                            dp[i][j-1] + 1,
                            dp[i-1][j-1] + cost);
        }
    }
    return dp[n][m];
}

int main() {
    char s1[MAXLEN+1], s2[MAXLEN+1];
    printf("文字列 s1 を入力: ");
    scanf("%s", s1);
    printf("文字列 s2 を入力: ");
    scanf("%s", s2);
    int dist = edit_distance(s1, s2);
    printf("編集距離: %d\n", dist);
    return 0;
}
        </code></pre>
      </div>
    </section>

    <!-- ================================
         2) 0/1 Knapsack
         ================================ -->
    <section id="knapControls" class="section algo-controls" style="display:none;">
      <h2 class="section-title">0/1 Knapsack</h2>
      <div class="controls">
        <label class="label">重みリスト（カンマ区切り）:
          <input type="text" id="knap_weights" class="input" placeholder="例: 2,3,4,5" />
        </label>
        <label class="label">価値リスト（カンマ区切り）:
          <input type="text" id="knap_values" class="input" placeholder="例: 3,4,5,6" />
        </label>
        <label class="label">容量 (capacity):
          <input type="number" id="knap_capacity" class="input" placeholder="例: 8" />
        </label>
        <label class="label">遅延 (秒):
          <input type="number" step="0.01" id="knap_delay" class="input" value="0.1" style="width: 60px;" />
        </label>
        <button id="knapInitBtn" class="btn">Initialize</button>
        <button id="knapRandomBtn" class="btn">ランダム生成</button>
      </div>

      <div id="knapTableWrapper" class="table-wrapper">
        <table id="knapTable"></table>
      </div>

      <div class="controls">
        <label class="label">
          Auto Play 倍率：
          <select id="knapSpeedSelect" class="select speed-select" style="max-width:120px; margin-left:4px;">
            <option value="0.5">0.5×</option>
            <option value="1.0" selected>1.0×</option>
            <option value="1.5">1.5×</option>
            <option value="2.0">2.0×</option>
            <option value="3.0">3.0×</option>
          </select>
        </label>
      </div>
      <div class="step-controls">
        <button id="knapPrevBtn" class="btn" disabled>前へ</button>
        <button id="knapNextBtn" class="btn" disabled>次へ</button>
        <button id="knapAutoBtn" class="btn" disabled>Auto Play</button>
      </div>
      <div id="knapProgress" class="progress">ステップ 0 / 0</div>
      <div id="knapDesc" class="description">
        <strong>0/1 Knapsack とは：</strong><br>
        限られた重さのキャパシティの中で、価値を最大化する問題です。<br>
        各品物は「重み」「価値」を持ち、選ぶ（1）・選ばない（0）の組み合わせを決めます。<br>
        DP テーブルを可視化し、「入れる場合」「入れない場合」の価値を比較します。<br>
        <strong>C 言語実装例：</strong>
        <pre><code>
// C 言語：0/1 Knapsack の例
#include <stdio.h>
#include <stdlib.h>

int max(int a, int b) { return (a > b) ? a : b; }

int knapsack(int W, int wt[], int val[], int n) {
    int dp[n+1][W+1];
    for (int i = 0; i <= n; i++) {
        for (int w = 0; w <= W; w++) {
            if (i == 0 || w == 0)
                dp[i][w] = 0;
            else if (wt[i-1] <= w)
                dp[i][w] = max(val[i-1] + dp[i-1][w - wt[i-1]],
                               dp[i-1][w]);
            else
                dp[i][w] = dp[i-1][w];
        }
    }
    return dp[n][W];
}

int main() {
    int val[] = {3, 4, 5, 6};
    int wt[]  = {2, 3, 4, 5};
    int W = 8;
    int n = sizeof(val) / sizeof(val[0]);
    printf("最大価値: %d\n", knapsack(W, wt, val, n));
    return 0;
}
        </code></pre>
      </div>
    </section>

    <!-- ================================
         3) Sorting（ソート）
         ================================ -->
    <section id="sortControls" class="section algo-controls" style="display:none;">
      <h2 class="section-title">Sorting（ソート）</h2>
      <div class="controls">
        <label class="label">ソート種類：
          <select id="sortAlgoSelect" class="select">
            <option value="bubble">バブルソート</option>
            <option value="quick">クイックソート</option>
            <option value="merge">マージソート</option>
            <option value="insert">挿入ソート</option>
            <option value="select">選択ソート</option>
          </select>
        </label>
        <label class="label">ソート対象リスト：
          <input type="text" id="sort_array" class="input" placeholder="例: 5,2,9,1,5" />
        </label>
        <label class="label">遅延 (秒):
          <input type="number" step="0.01" id="sort_delay" class="input" value="0.2" style="width: 60px;" />
        </label>
        <button id="sortInitBtn" class="btn">Initialize</button>
        <button id="sortRandomBtn" class="btn">ランダム生成</button>
      </div>

      <div id="sortBars" class="bars-wrapper"></div>

      <div class="controls">
        <label class="label">
          Auto Play 倍率：
          <select id="sortSpeedSelect" class="select speed-select" style="max-width:120px; margin-left:4px;">
            <option value="0.5">0.5×</option>
            <option value="1.0" selected>1.0×</option>
            <option value="1.5">1.5×</option>
            <option value="2.0">2.0×</option>
            <option value="3.0">3.0×</option>
          </select>
        </label>
      </div>
      <div class="step-controls">
        <button id="sortPrevBtn" class="btn" disabled>前へ</button>
        <button id="sortNextBtn" class="btn" disabled>次へ</button>
        <button id="sortAutoBtn" class="btn" disabled>Auto Play</button>
      </div>
      <div id="sortProgress" class="progress">ステップ 0 / 0</div>
      <div id="sortDesc" class="description">
        <strong>ソート (Sorting) とは：</strong><br>
        配列を昇順（小さい順）に並び替える操作です。<br>
        以下に代表的なソートアルゴリズムの C 言語実装例を示します。

        <strong>■ バブルソート (Bubble Sort)</strong>
        <pre><code>
// C 言語：バブルソートの例
#include <stdio.h>
void bubbleSort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - 1 - i; j++) {
            if (arr[j] > arr[j+1]) {
                int tmp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = tmp;
            }
        }
    }
}
int main() {
    int arr[] = {5,2,9,1,5};
    int n = sizeof(arr)/sizeof(arr[0]);
    bubbleSort(arr, n);
    for (int i = 0; i < n; i++) printf("%d ", arr[i]);
    printf("\n");
    return 0;
}
        </code></pre>

        <strong>■ クイックソート (Quick Sort)</strong>
        <pre><code>
// C 言語：クイックソートの例
#include <stdio.h>
int partition(int a[], int low, int high) {
    int pivot = a[high];
    int i = low - 1;
    for (int j = low; j < high; j++) {
        if (a[j] < pivot) {
            i++;
            int tmp = a[i];
            a[i] = a[j];
            a[j] = tmp;
        }
    }
    int tmp = a[i+1];
    a[i+1] = a[high];
    a[high] = tmp;
    return i + 1;
}
void quickSort(int a[], int low, int high) {
    if (low < high) {
        int pi = partition(a, low, high);
        quickSort(a, low, pi - 1);
        quickSort(a, pi + 1, high);
    }
}
int main() {
    int arr[] = {5,2,9,1,5};
    int n = sizeof(arr)/sizeof(arr[0]);
    quickSort(arr, 0, n-1);
    for (int i = 0; i < n; i++) printf("%d ", arr[i]);
    printf("\n");
    return 0;
}
        </code></pre>

        <strong>■ マージソート (Merge Sort)</strong>
        <pre><code>// C 言語：マージソートの例
#include <stdio.h>
#include <stdlib.h>
void merge(int a[], int l, int m, int r) {
    int n1 = m - l + 1, n2 = r - m;
    int *L = malloc(sizeof(int) * n1);
    int *R = malloc(sizeof(int) * n2);
    for (int i = 0; i < n1; i++) L[i] = a[l + i];
    for (int j = 0; j < n2; j++) R[j] = a[m + 1 + j];
    int i = 0, j = 0, k = l;
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) a[k++] = L[i++];
        else           a[k++] = R[j++];
    }
    while (i < n1) a[k++] = L[i++];
    while (j < n2) a[k++] = R[j++];
    free(L); free(R);
}
void mergeSort(int a[], int l, int r) {
    if (l < r) {
        int m = (l + r) / 2;
        mergeSort(a, l, m);
        mergeSort(a, m + 1, r);
        merge(a, l, m, r);
    }
}
int main() {
    int arr[] = {5,2,9,1,5};
    int n = sizeof(arr)/sizeof(arr[0]);
    mergeSort(arr, 0, n-1);
    for (int i = 0; i < n; i++) printf("%d ", arr[i]);
    printf("\n");
    return 0;
}
        </code></pre>

        <strong>■ 挿入ソート (Insertion Sort)</strong>
        <pre><code>
// C 言語：挿入ソートの例
#include <stdio.h>
void insertionSort(int a[], int n) {
    for (int i = 1; i < n; i++) {
        int key = a[i];
        int j = i - 1;
        while (j >= 0 && a[j] > key) {
            a[j + 1] = a[j];
            j--;
        }
        a[j + 1] = key;
    }
}
int main() {
    int arr[] = {5,2,9,1,5};
    int n = sizeof(arr)/sizeof(arr[0]);
    insertionSort(arr, n);
    for (int i = 0; i < n; i++) printf("%d ", arr[i]);
    printf("\n");
    return 0;
}
        </code></pre>

        <strong>■ 選択ソート (Selection Sort)</strong>
        <pre><code>
// C 言語：選択ソートの例
#include <stdio.h>
void selectionSort(int a[], int n) {
    for (int i = 0; i < n - 1; i++) {
        int minIdx = i;
        for (int j = i + 1; j < n; j++) {
            if (a[j] < a[minIdx]) minIdx = j;
        }
        int tmp = a[i];
        a[i] = a[minIdx];
        a[minIdx] = tmp;
    }
}
int main() {
    int arr[] = {5,2,9,1,5};
    int n = sizeof(arr)/sizeof(arr[0]);
    selectionSort(arr, n);
    for (int i = 0; i < n; i++) printf("%d ", arr[i]);
    printf("\n");
    return 0;
}
        </code></pre>
      </div>
    </section>

    <!-- ================================
         4) Searching（線形探索／2分探索／番兵法）
         ================================ -->
    <section id="searchControls" class="section algo-controls" style="display:none;">
      <h2 class="section-title">Searching（探索）</h2>
      <div class="controls">
        <label class="label">探索方法：
          <select id="searchAlgoSelect" class="select">
            <option value="linear">線形探索 (Linear)</option>
            <option value="binary">2分探索 (Binary)</option>
            <option value="sentinel">番兵法 (Sentinel)</option>
          </select>
        </label>
        <label class="label">探索対象リスト：
          <input type="text" id="search_array" class="input" placeholder="例: 1,2,3,5,7,8" />
        </label>
        <label class="label">探索キー：
          <input type="number" id="search_key" class="input" placeholder="例: 5" />
        </label>
        <label class="label">遅延 (秒):
          <input type="number" step="0.01" id="search_delay" class="input" value="0.2" style="width: 60px;" />
        </label>
        <button id="searchInitBtn" class="btn">Initialize</button>
        <button id="searchRandomBtn" class="btn">ランダム生成</button>
      </div>

      <div id="searchBars" class="bars-wrapper"></div>

      <div class="controls">
        <label class="label">
          Auto Play 倍率：
          <select id="searchSpeedSelect" class="select speed-select" style="max-width:120px; margin-left:4px;">
            <option value="0.5">0.5×</option>
            <option value="1.0" selected>1.0×</option>
            <option value="1.5">1.5×</option>
            <option value="2.0">2.0×</option>
            <option value="3.0">3.0×</option>
          </select>
        </label>
      </div>
      <div class="step-controls">
        <button id="searchPrevBtn" class="btn" disabled>前へ</button>
        <button id="searchNextBtn" class="btn" disabled>次へ</button>
        <button id="searchAutoBtn" class="btn" disabled>Auto Play</button>
      </div>
      <div id="searchProgress" class="progress">ステップ 0 / 0</div>
      <div id="searchDesc" class="description">
        <strong>探索 (Searching) とは：</strong><br>
        配列から特定の値（キー）を見つける操作です。<br>
        <ul>
          <li>線形探索：先頭から順次チェック</li>
          <li>2分探索：あらかじめソート済み配列から中央を比較し範囲を半分に絞る</li>
          <li>番兵法：末尾に「番兵」を追加してループ条件をシンプルに</li>
        </ul>
        <strong>C 言語実装例：</strong>

        <strong>■ 線形探索 (Linear Search)</strong>
        <pre><code>
// C 言語：線形探索の例
#include <stdio.h>
int linearSearch(int arr[], int n, int key) {
    for (int i = 0; i < n; i++) {
        if (arr[i] == key) return i; // 見つかったインデックスを返す
    }
    return -1; // 見つからない場合
}
int main() {
    int arr[] = {1,2,3,5,7,8};
    int n = sizeof(arr)/sizeof(arr[0]);
    int key = 5;
    int idx = linearSearch(arr, n, key);
    if (idx != -1) printf("キー %d はインデックス %d にあります。\n", key, idx);
    else printf("キー %d は見つかりません。\n", key);
    return 0;
}
        </code></pre>

        <strong>■ 2分探索 (Binary Search)</strong>
        <pre><code>
// C 言語：2分探索の例（配列はソート済みであることが前提）
#include <stdio.h>
int binarySearch(int arr[], int n, int key) {
    int left = 0, right = n - 1;
    while (left <= right) {
        int mid = (left + right) / 2;
        if (arr[mid] == key) return mid;
        else if (arr[mid] < key) left = mid + 1;
        else right = mid - 1;
    }
    return -1;
}
int main() {
    int arr[] = {1,2,3,5,7,8};
    int n = sizeof(arr)/sizeof(arr[0]);
    int key = 5;
    int idx = binarySearch(arr, n, key);
    if (idx != -1) printf("キー %d はインデックス %d にあります。\n", key, idx);
    else printf("キー %d は見つかりません。\n", key);
    return 0;
}
        </code></pre>

        <strong>■ 番兵法 (Sentinel Search)</strong>
        <pre><code>
// C 言語：番兵法の例
#include <stdio.h>
int sentinelSearch(int arr[], int n, int key) {
    int last = arr[n - 1];
    arr[n - 1] = key; // 番兵を設定
    int i = 0;
    while (arr[i] != key) i++;
    arr[n - 1] = last; // 元に戻す
    if (i < n - 1 || arr[n - 1] == key) return i;
    return -1;
}
int main() {
    int arr[6] = {1,2,3,5,7,8};
    int n = 6;
    int key = 4;
    int idx = sentinelSearch(arr, n, key);
    if (idx != -1) printf("キー %d はインデックス %d にあります。\n", key, idx);
    else printf("キー %d は見つかりません。\n", key);
    return 0;
}
        </code></pre>
      </div>
    </section>

    <!-- ================================
         5) Forward アルゴリズム（HMM）
         ================================ -->
    <section id="forwardControls" class="section algo-controls" style="display:none;">
      <h2 class="section-title">Forward アルゴリズム（HMM）</h2>
      <div class="controls">
        <label class="label">状態（カンマ区切り）：
          <input type="text" id="fwd_states" class="input" placeholder="例: Rainy,Sunny" />
        </label>
        <label class="label">観測系列（カンマ区切り）：
          <input type="text" id="fwd_obs" class="input" placeholder="例: walk,shop,clean" />
        </label>
      </div>
      <div class="controls">
        <label class="label">初期確率 π（コンマ区切り；状態順）：
          <input type="text" id="fwd_pi" class="input" placeholder="例: 0.6,0.4" />
        </label>
      </div>
      <div class="controls">
        <label class="label">遷移確率 A（行ごとにカンマ区切り，改行区切り）：
          <textarea id="fwd_A" class="input" rows="3"
            placeholder="例：
0.7,0.3
0.4,0.6"></textarea>
        </label>
      </div>
      <div class="controls">
        <label class="label">出力確率 B（行ごとにカンマ区切り，改行区切り）：
          <textarea id="fwd_B" class="input" rows="3"
            placeholder="例：
0.1,0.4,0.5
0.6,0.3,0.1"></textarea>
        </label>
      </div>
      <div class="controls">
        <button id="fwdInitBtn" class="btn">Initialize</button>
        <button id="fwdRandomBtn" class="btn">ランダム生成</button>
      </div>

      <div id="fwdTableWrapper" class="table-wrapper">
        <table id="fwdTable" class="trellis-table"></table>
      </div>

      <div class="controls">
        <label class="label">
          Auto Play 倍率：
          <select id="fwdSpeedSelect" class="select speed-select" style="max-width:120px; margin-left:4px;">
            <option value="0.5">0.5×</option>
            <option value="1.0" selected>1.0×</option>
            <option value="1.5">1.5×</option>
            <option value="2.0">2.0×</option>
            <option value="3.0">3.0×</option>
          </select>
        </label>
      </div>
      <div class="step-controls">
        <button id="fwdPrevBtn" class="btn" disabled>前へ</button>
        <button id="fwdNextBtn" class="btn" disabled>次へ</button>
        <button id="fwdAutoBtn" class="btn" disabled>Auto Play</button>
      </div>
      <div id="fwdProgress" class="progress">ステップ 0 / 0</div>
      <div id="fwdDesc" class="description">
        <strong>Forward アルゴリズムとは：</strong><br>
        HMM（隠れマルコフモデル）において、観測系列が与えられたとき、
        観測系列の尤度を効率的に求める手法です。<br>
        トレリス（時間×状態 の格子）を使い、ステップごとに確率を更新していきます。<br>
        <strong>C 言語実装例：</strong>
        <pre><code>
// C 言語：Forward アルゴリズムの例
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define MAXT 100
#define MAXN 10

double pi[MAXN];       // 初期確率
double A[MAXN][MAXN];  // 遷移確率
double B[MAXN][MAXT];  // 出力確率
double alpha[MAXT][MAXN];

int main() {
    int N, T; // N: 状態数, T: 観測系列長
    char states[MAXN][16];
    char obs[MAXT][16];

    // --- 入力省略：ここでは定数として与える例 ---
    N = 2; T = 3;
    strcpy(states[0], "Rainy"); strcpy(states[1], "Sunny");
    strcpy(obs[0], "walk"); strcpy(obs[1], "shop"); strcpy(obs[2], "clean");
    pi[0] = 0.6; pi[1] = 0.4;
    A[0][0] = 0.7; A[0][1] = 0.3;
    A[1][0] = 0.4; A[1][1] = 0.6;
    // B[状態][観測インデックス]
    double bRainy[] = {0.1,0.4,0.5};
    double bSunny[] = {0.6,0.3,0.1};
    memcpy(B[0], bRainy, sizeof(double)*3);
    memcpy(B[1], bSunny, sizeof(double)*3);

    // t=0 初期化
    for (int i = 0; i < N; i++) {
        alpha[0][i] = pi[i] * B[i][0]; // 観測 obs[0] のインデックスは例として 0 とする
        printf("t=0, 状態 %s: alpha = %f\n", states[i], alpha[0][i]);
    }
    // t=1..T-1
    for (int t = 1; t < T; t++) {
        for (int j = 0; j < N; j++) {
            double sum = 0.0;
            for (int i = 0; i < N; i++) {
                sum += alpha[t-1][i] * A[i][j];
            }
            alpha[t][j] = sum * B[j][t]; // 観測 obs[t] のインデックスは t としている
            printf("t=%d, 状態 %s: alpha = %f\n", t, states[j], alpha[t][j]);
        }
    }
    // 最終尤度
    double prob = 0.0;
    for (int i = 0; i < N; i++) prob += alpha[T-1][i];
    printf("観測系列の尤度 = %f\n", prob);
    return 0;
}
        </code></pre>
      </div>
    </section>

    <!-- ================================
         6) Viterbi アルゴリズム（HMM）
         ================================ -->
    <section id="viterbiControls" class="section algo-controls" style="display:none;">
      <h2 class="section-title">Viterbi アルゴリズム（HMM）</h2>
      <div class="controls">
        <label class="label">状態（カンマ区切り）：
          <input type="text" id="vit_states" class="input" placeholder="例: Rainy,Sunny" />
        </label>
        <label class="label">観測系列（カンマ区切り）：
          <input type="text" id="vit_obs" class="input" placeholder="例: walk,shop,clean" />
        </label>
      </div>
      <div class="controls">
        <label class="label">初期確率 π（コンマ区切り；状態順）：
          <input type="text" id="vit_pi" class="input" placeholder="例: 0.6,0.4" />
        </label>
      </div>
      <div class="controls">
        <label class="label">遷移確率 A（行ごとにカンマ区切り，改行区切り）：
          <textarea id="vit_A" class="input" rows="3"
            placeholder="例：
0.7,0.3
0.4,0.6"></textarea>
        </label>
      </div>
      <div class="controls">
        <label class="label">出力確率 B（行ごとにカンマ区切り，改行区切り）：
          <textarea id="vit_B" class="input" rows="3"
            placeholder="例：
0.1,0.4,0.5
0.6,0.3,0.1"></textarea>
        </label>
      </div>
      <div class="controls">
        <button id="vitInitBtn" class="btn">Initialize</button>
        <button id="vitRandomBtn" class="btn">ランダム生成</button>
      </div>

      <div id="vitTableWrapper" class="table-wrapper">
        <table id="vitTable" class="trellis-table"></table>
      </div>

      <div class="controls">
        <label class="label">
          Auto Play 倍率：
          <select id="vitSpeedSelect" class="select speed-select" style="max-width:120px; margin-left:4px;">
            <option value="0.5">0.5×</option>
            <option value="1.0" selected>1.0×</option>
            <option value="1.5">1.5×</option>
            <option value="2.0">2.0×</option>
            <option value="3.0">3.0×</option>
          </select>
        </label>
      </div>
      <div class="step-controls">
        <button id="vitPrevBtn" class="btn" disabled>前へ</button>
        <button id="vitNextBtn" class="btn" disabled>次へ</button>
        <button id="vitAutoBtn" class="btn" disabled>Auto Play</button>
      </div>
      <div id="vitProgress" class="progress">ステップ 0 / 0</div>
      <div id="vitDesc" class="description">
        <strong>Viterbi アルゴリズムとは：</strong><br>
        HMM において、観測系列が与えられたとき、
        最も尤もらしい（最大尤度の）隠れ状態列を求める手法です。<br>
        トレリス（時間×状態 の格子）を使い、ステップごとに最適経路とその確率を更新していきます。<br>
        <strong>C 言語実装例：</strong>
        <pre><code>
// C 言語：Viterbi アルゴリズムの例
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define MAXT 100
#define MAXN 10

double pi[MAXN];       // 初期確率
double A[MAXN][MAXN];  // 遷移確率
double B[MAXN][MAXT];  // 出力確率
double delta[MAXT][MAXN];
int psi[MAXT][MAXN];

int main() {
    int N, T; // N: 状態数, T: 観測系列長
    char states[MAXN][16];
    char obs[MAXT][16];

    // --- 入力省略：ここでは定数として与える例 ---
    N = 2; T = 3;
    strcpy(states[0], "Rainy"); strcpy(states[1], "Sunny");
    strcpy(obs[0], "walk"); strcpy(obs[1], "shop"); strcpy(obs[2], "clean");
    pi[0] = 0.6; pi[1] = 0.4;
    A[0][0] = 0.7; A[0][1] = 0.3;
    A[1][0] = 0.4; A[1][1] = 0.6;
    double bRainy[] = {0.1,0.4,0.5};
    double bSunny[] = {0.6,0.3,0.1};
    memcpy(B[0], bRainy, sizeof(double)*3);
    memcpy(B[1], bSunny, sizeof(double)*3);

    // t=0 初期化
    for (int i = 0; i < N; i++) {
        delta[0][i] = pi[i] * B[i][0]; // 観測 obs[0] のインデックスは 0
        psi[0][i] = 0;
        printf("t=0, 状態 %s: delta = %f\n", states[i], delta[0][i]);
    }
    // t=1..T-1
    for (int t = 1; t < T; t++) {
        for (int j = 0; j < N; j++) {
            double maxVal = -1.0;
            int maxState = 0;
            for (int i = 0; i < N; i++) {
                double val = delta[t-1][i] * A[i][j];
                if (val > maxVal) {
                    maxVal = val;
                    maxState = i;
                }
            }
            delta[t][j] = maxVal * B[j][t]; // 観測 obs[t] のインデックスは t
            psi[t][j] = maxState;
            printf("t=%d, 状態 %s: delta = %f (prev=%s)\n",
                   t, states[j], delta[t][j], states[maxState]);
        }
    }
    // 最尤終端
    double finalMax = -1.0;
    int finalState = 0;
    for (int i = 0; i < N; i++) {
        if (delta[T-1][i] > finalMax) {
            finalMax = delta[T-1][i];
            finalState = i;
        }
    }
    printf("最尤終端: 状態=%s, 確率=%f\n", states[finalState], finalMax);
    return 0;
}
        </code></pre>
      </div>
    </section>

    <!-- ================================
         7) 線形計画法（単純形法）
         ================================ -->
    <section id="lpControls" class="section algo-controls" style="display:none;">
      <h2 class="section-title">線形計画法（単純形法）</h2>
      <div class="controls">
        <textarea id="lp_input" class="input" rows="4" placeholder="
例：
maximize 3x + 2y
s.t.
 x +  y ≤ 5
2x + 3y ≤ 12
 x ≤ 3
 y ≤ 4
"></textarea>
        <button id="lpInitBtn" class="btn">Initialize</button>
        <button id="lpRandomBtn" class="btn">ランダム生成</button>
      </div>

      <div id="simplexContainer">
        <table id="simplexTable" class="simplex-table"></table>
      </div>

      <div class="controls">
        <label class="label">
          Auto Play 倍率：
          <select id="lpSpeedSelect" class="select speed-select" style="max-width:120px; margin-left:4px;">
            <option value="0.5">0.5×</option>
            <option value="1.0" selected>1.0×</option>
            <option value="1.5">1.5×</option>
            <option value="2.0">2.0×</option>
            <option value="3.0">3.0×</option>
          </select>
        </label>
      </div>
      <div class="step-controls">
        <button id="lpPrevBtn" class="btn" disabled>前へ</button>
        <button id="lpNextBtn" class="btn" disabled>次へ</button>
        <button id="lpAutoBtn" class="btn" disabled>Auto Play</button>
      </div>
      <div id="lpProgress" class="progress">ステップ 0 / 0</div>
      <div id="lpDesc" class="description">
        <strong>線形計画法（LP）とは：</strong><br>
        目的関数と複数の線形不等式制約から成る最適化問題を解く手法です。<br>
        「単純形表」を使い、ステップごとにピボット操作を可視化します。<br>
        <strong>C 言語実装例（簡易版）：</strong>
        <pre><code>
// C 言語：単純形法の簡易実装サンプル
#include <stdio.h>
#define MAXV 10
#define MAXC 10

// ここでは簡易化のため、固定サイズで実装例を示します。
// 実用的には行列操作・動的メモリ管理が必要です。

int main() {
    // maximize 3x + 2y
    // s.t. x + y ≤ 5, 2x + 3y ≤ 12, x ≤ 3, y ≤ 4
    double tableau[5][7] = {
        {1,  1,  0,  0,  1, 5, 0},  // x + y + s1 = 5
        {2,  3,  0,  0,  0,12, 0},  // 2x + 3y + s2 = 12
        {1,  0,  0,  0,  0, 3, 0},  // x + s3 = 3
        {0,  1,  0,  0,  0, 4, 0},  // y + s4 = 4
        {-3,-2,  0,  0,  0, 0, 0}   // 目的関数行 (-3x -2y + z = 0)
    };
    // ここからピボット操作を繰り返す…
    printf("簡易版：詳細な実装は省略します。\n");
    return 0;
}
        </code></pre>
      </div>
    </section>

    <!-- ================================
         8) ハッシュ法（オープンアドレス法）
         ================================ -->
    <section id="hashControls" class="section algo-controls" style="display:none;">
      <h2 class="section-title">ハッシュ法（オープンアドレス法）</h2>
      <div class="controls">
        <label class="label">テーブルサイズ：
          <input type="number" id="hash_m" class="input" value="11" min="5" style="width: 80px;" />
        </label>
        <label class="label">キー列（カンマ区切り）：
          <input type="text" id="hash_keys" class="input" placeholder="例: 15,11,27,8,12" />
        </label>
        <label class="label">
          ハッシュ関数 h(k) = k mod m の m を上記テーブルサイズで使用
        </label>
        <button id="hashInitBtn" class="btn">Initialize</button>
        <button id="hashRandomBtn" class="btn">ランダム生成</button>
      </div>

      <div id="hashContainer" class="hash-container">
        <!-- オープンアドレス法の各スロットを .hash-slot で並べる -->
      </div>

      <div class="controls">
        <label class="label">
          Auto Play 倍率：
          <select id="hashSpeedSelect" class="select speed-select" style="max-width:120px; margin-left:4px;">
            <option value="0.5">0.5×</option>
            <option value="1.0" selected>1.0×</option>
            <option value="1.5">1.5×</option>
            <option value="2.0">2.0×</option>
            <option value="3.0">3.0×</option>
          </select>
        </label>
      </div>
      <div class="step-controls">
        <button id="hashPrevBtn" class="btn" disabled>前へ</button>
        <button id="hashNextBtn" class="btn" disabled>次へ</button>
        <button id="hashAutoBtn" class="btn" disabled>Auto Play</button>
      </div>
      <div id="hashProgress" class="progress">ステップ 0 / 0</div>
      <div id="hashDesc" class="description">
        <strong>ハッシュ法（オープンアドレス法）とは：</strong><br>
        散列関数 h(k) = k mod m を使い、ハッシュテーブルにキーを挿入する手法です。<br>
        衝突が起きた場合は逐次探索（リニアプロービング）で空きスロットを探します。<br>
        各ステップの衝突・挿入状況を可視化します。<br>
        <strong>C 言語実装例：</strong>
        <pre><code>
// C 言語：オープンアドレス法の例（リニアプロービング）
#include <stdio.h>
#define EMPTY -1

int hash_function(int key, int m) {
    return key % m;
}

void insert_linear(int table[], int m, int key) {
    int idx = hash_function(key, m);
    int i = 0;
    while (i < m) {
        int slot = (idx + i) % m;
        if (table[slot] == EMPTY) {
            table[slot] = key;
            printf("キー %d をスロット %d に挿入\n", key, slot);
            return;
        } else {
            printf("衝突: スロット %d は %d が入っている\n", slot, table[slot]);
            i++;
        }
    }
    printf("テーブルが満杯: キー %d を挿入できません\n", key);
}

int main() {
    int m = 11;
    int table[11];
    for (int i = 0; i < 11; i++) table[i] = EMPTY;
    int keys[] = {15,11,27,8,12};
    int n = sizeof(keys)/sizeof(keys[0]);
    for (int i = 0; i < n; i++) {
        insert_linear(table, m, keys[i]);
    }
    return 0;
}
        </code></pre>
      </div>
    </section>
  </main>

  <!-- 外部JS を読み込む -->
  <script src="js/main.js"></script>
</body>
</html>
